#!/usr/bin/env node

/* jshint node: true */

// TODO: Handle references.

'use strict';

/**
 * A type for types.
 *
 * Useful for many things, here for schema generation and compression.
 *
 * Usages (input is always read from stdin):
 *
 *  $ meta compress # Encode schema as Avro bytes.
 *  $ meta decompress # Decompress schema from above representation.
 *  $ meta random # Generate random schema (might overflow, just retry if so).
 *
 * Warning: randomly generated schemas aren't guaranteed to compile since they
 * might include empty fields and unions or undefined references.
 *
 */

var avro = require('../../lib'),
    util = require('util');


/**
 * Transform a canonical schema into its type.
 *
 */
function MetaType(attrs, opts) {
  avro.types.LogicalType.call(this, attrs, opts);
}
util.inherits(MetaType, avro.types.LogicalType);

MetaType.prototype._fromValue = function (val) { return avro.parse(val); };

MetaType.prototype._toValue = function (any) { return any.toJSON(); };

/**
 * Deal with Avro's inconsistent union representation.
 *
 */
function NamedUnionType(attrs, opts) {
  avro.types.LogicalType.call(this, attrs, opts);
}
util.inherits(NamedUnionType, avro.types.LogicalType);

NamedUnionType.prototype._fromValue = function (val) {
  var obj = val.value;
  return obj[Object.keys(obj)[0]];
};

NamedUnionType.prototype._toValue = function (any) {
  var obj;
  if (typeof any == 'string') {
    obj = {string: any};
  } else if (avro.Type.isType(any, 'union')) {
    obj = {array: any.getTypes()};
  } else {
    obj = {};
    obj[any.constructor.name_] = any;
  }
  return {value: obj};
};


// Finally.
var META_TYPE = avro.parse({
  name: 'MetaType',
  type: 'record',
  logicalType: 'union',
  fields: [
    {
      name: 'value',
      type: [
        derived('array', [{name: 'items', type: 'MetaType'}]),
        primitive('boolean'),
        primitive('bytes'),
        primitive('double'),
        derived('enum', [
          {name: 'name', type: 'string'},
          {name: 'symbols', type: {type: 'array', items: 'string'}}
        ]),
        derived('fixed', [
          {name: 'name', type: 'string'},
          {name: 'size', type: 'int'}
        ]),
        primitive('float'),
        primitive('int'),
        derived('map', [{name: 'values', type: 'MetaType'}]),
        primitive('long'),
        primitive('null'),
        derived('record', [
          {name: 'name', type: 'string'},
          {
            name: 'fields',
            type: {
              type: 'array',
              items: {
                name: 'Field',
                type: 'record',
                fields: [
                  {name: 'name', type: 'string'},
                  {name: 'type', type: 'MetaType'}
                ]
              }
            }
          }
        ]),
        primitive('string'),
        {type: 'array', items: 'MetaType'}, // Union.
        'string' // Reference (not fully supported yet).
      ]
    }
  ]
}, {logicalTypes: {meta: MetaType, union: NamedUnionType}, wrapUnions: true});


// Example of things we can do.
switch (process.argv[2]) {
  case 'compress':
    readInput(function (err, buf) {
      if (err) {
        throw err;
      }
      process.stdout.write(META_TYPE.toBuffer(avro.parse(buf.toString())));
    });
    break;
  case 'decompress':
    readInput(function (err, buf) {
      if (err) {
        throw err;
      }
      console.log(META_TYPE.fromBuffer(buf).getSchema());
    });
    break;
  case 'random':
    console.log(JSON.stringify(META_TYPE.random()));
    break;
  default:
    var exec = process.argv[1];
    console.error(util.format('usage: %s (compress|decompress|random)', exec));
    process.exit(1);
}


// Helpers, mostly to generate repetitive parts of the schema.

function primitive(name) {
  return {
    name: capitalize(name) + 'Type',
    type: 'enum',
    logicalType: 'meta',
    symbols: [name]
  };
}

function derived(name, fields) {
  var typeName = capitalize(name) + 'Type';
  fields.unshift({
    name: 'type',
    type: {type: 'enum', name: typeName + 'Name', symbols: [name]}
  });
  return {name: typeName, type: 'record', logicalType: 'meta', fields: fields};
}

function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

function readInput(cb) {
  var bufs = [];
  process.stdin
    .on('error', cb)
    .on('data', function (buf) { bufs.push(buf); })
    .on('end', function () { cb(null, Buffer.concat(bufs)); });
}
